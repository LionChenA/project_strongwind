# 参考资源
b 站视频 [【计算机科学速成课】[40 集全/精校]](  https://www.bilibili.com/video/BV1EW411u7th/?vd_source=60e5f9d96096ae226721a70811437244 )
☆☆☆超详细脑图：[计算机科学速成课（计组部分）](https://www.processon.com/view/link/61ef6e8f0e3e7439ae917672#outline)
参考笔记：[公开分享版本【计算机科学速成课】 笔记](https://shimo.im/docs/PJAUY30F1uYksv0h/read)
中文字幕文本 [Crash-Course-Computer-Science-Chinese/(字幕) 全 40 集中英字幕文本]( https://github.com/1c7/Crash-Course-Computer-Science-Chinese/blob/master/ (%E5%AD%97%E5%B9%95)%E5%85%A840%E9%9B%86%E4%B8%AD%E8%8B%B1%E5%AD%97%E5%B9%95%E6%96%87%E6%9C%AC. txt)

# 计算机早期历史

> 随着知识的增长和新工具的诞生，人工劳力会越来越少 - [[Charles Babbage]]

大约**公元前 2500 年**，**算盘**发明于"美索不达米亚"，这是公认最早的计算设备是。它是一种手动计算器，用来帮助加减数字，人们制造算盘是因为社会的规模已经超出个人心算的能力。
自此以后的 4000 余年，人们创造了各种巧妙的计算设备，如星盘，让船只可以在海上计算纬度，或计算尺，帮助计算乘法和除法。人们还创造了上百种时钟，用来计算日出，潮汐，天体的位置，或纯粹拿来计时。这些设备让原先很费力的事变得**更快、更简单、更精确、降低了门槛、加强了我们的能力**。
公元 **1613 年**，首次提出了 **Computer** 的概念，但当时指的是负责做计算的人，而不是机器。
**1694 年**，**步进计算机**出现，其加减法的运算原理和算盘一致，通过加减法的累加实现了乘除，这是**世界上第一台**能自动完成加减乘除四则运算的计算机器。
同时期，由于步进计算机昂贵的价格和缓慢的运算，**计算表**兴起。计算表由“人力计算器”编辑，类似于**字典**，可用于查找各种庞大的计算值。比如，二战中，为了迅速计算炮弹的落点，射程表被广泛应用，但问题在于，一旦更改了大炮或炮弹的任何设计，都需要重新进行运算。
1823 年 [[Charles Babbage]] 提出了**差分机**，用于解决多项式计算的问题，但遗憾的是失败了。 
19 世纪中期，[[Charles Babbage]] 在建造差分机的过程中构想出新的计算机器-**分析机**。分析机不同于步进计算机、差分机等，它是一个“**通用计算机**”，此外，分析机可以对给定的数据执行一系列预设的操作指令，它甚至还有内存和打印机。同样，该计划因太超前也失败了。但这种**自动计算机**的跨时代概念直接带来了计算机程序的出现：[[Ada Lovelace]] 给分析机写了假想的程序，并预示了计算机语言的诞生，被认为是世界上**第一位**程序员。分析机激励了第一代计算机科学家，因而 [[Charles Babbage]] 被称为**计算之父**。
1890 年，由于美国人口普查工作过于繁重，[[Herman Hollerith]] 发明了**打孔卡片制表机**以解决人口普查中的计算问题。打孔卡片制表机的工作原理是：在纸上打孔—>孔穿过针—>针泡入汞—>电路连通—>齿轮使计数+1。打孔卡片制表机的出现使得企业注意到了计算的价值，这使得 [[Herman Hollerith]] 成立了制表机器公司，这家公司在 1924 年与其他机械公司合并为 Internet Business Machine Coporation，即现在的 [[IBM]]。

# 电子计算机

**哈佛 Mark 1 号**，由 [[IBM]] 在 1944 年制造，为世界上最大的机电计算机之一，这台机器由==继电器==组成，继电器使用了电磁驱动的机械开关。这不仅限制了计算的速度，还会在运算过程中出现机械磨损。由于使用了大量继电器，这台机器同样容易出现故障，**哈佛 Mark 2 号**的操作员在其中发现了一只虫子 (bug)，计算机术语 bug 就此诞生。

1904 年 [[John Ambrose Fleming]] 发明了==热电子管==，这是世界上第一个**真空管**，通过加热阴极来激发电子，当阳极带正电时即可吸引电子
1906 年，[[Lee de Forest]] 改进了热电子管，增加了控制电极。热电子管将机械的开关变成了，避免了磨损，但激发电子的温度使其会像灯泡一样烧坏，真空的构造使其十分脆弱。经过可靠性和成本上的改进，1940 年，热电子管初步具备了成为计算机远见的可能性。
1941 年 [[Alan Turing]] ，设计了**机电设备 Bombe**，用于破解纳粹的“英格码”。
1943 年，由 [[Tommy Flowers]] 设计的**巨人 1 号**是首次大规模使用**真空管**（三极管）制作的计算机，用于破解纳粹通信。这也是世界上第一个可编程的计算机，虽然序言通过把几百根电线插入插板来实现
1946 年宾夕法尼亚大学推出了世界上第一个正真通用、可编程的电子计算机 **ENIAC**。
1950 年代，真空管到达计算极限，空军 AN/FSQ-7 于 1955 年完成，用于防空系统

1947 年，[[贝尔实验室]]发明了==晶体管==，使用了固态的**半导体材料**，相对真空管不仅拥有更快的开关切换速度，还更加可靠。晶体管的发明标志着一个全新的计算机时代的诞生。晶体管的出现大大降低了计算机的成本和体积，使得消费级的计算机成为可能。
1957 年，第一个消费者**可购买**的晶体管计算机 **IBM 608** 由 [[IBM]] 推出。
晶体管和半导体的开发主要位于[[圣克拉拉谷]]，由于半导体的主要材料是硅，因而也被称为[[硅谷]]。

这一讲讲了计算机的基本元件的发展过程：由继电器到热电子管，再到晶体管。元器件的开关切换能力和数量直接决定了计算机的计算能力。
# 布尔逻辑和逻辑门
## 什么是二进制 ？
二进制 binary，用两种状态表示。电路闭合，电流流过，代表真 (1，true)；电路断开，无电流流过，代表假 (0，false)
## 为什么使用二进制 ？
1. 尽管可以使用电流的强度作为信号，但计算的状态越多，信号越容易受到干扰，从而影响计算的精确性
2. 计算机的元器件晶体管只有 **2** 种状态，通电（1）& 断电（0），用二进制可直接根据元器件的状态来设计计算机
3. 存在一个专门处理真和假的数学分支，即**布尔代数**，它解决所有法则和运算，即可用二进制实现任意运算。
[[George Boole]] 是布尔二字的由来
## 布尔代数的简介
布尔代数中，变量的值是 true 和 false ，可以进行逻辑运算。
布尔代数的三个基本操作：NOT AND OR

一个晶体管即可表示 NOT 的操作
两个晶体管串联表示 AND 的操作
两个晶体管并联表示 OR 的操作
 
特殊操作异或 XOR ，两个对象相同时输出 false，不同时输出 true
![500](https://cly1-1305183930.file.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-11-17%2020.13.16.png)


学了这一讲后，我有几个疑问
1. 布尔代数和 [[George Boole]] 的关系
2. 布尔代数和二进制的关系
3. 
总结：本节讲了计算机底层的二进制，并讲了基本的逻辑值：==真/假 (或者说 1/0)== 和基本的逻辑运算：NOT、AND、OR 以及特殊的逻辑操作 XOR 异或。这些操作都可由一个乃至数个晶体管组合实现。程序员可使用对应的逻辑操作而不需要了解其背后的实现，由晶体管的组合到对应的逻辑操作我们称完成了一次抽象，计算机科学的大厦就是在这样的一次次抽象中构建出来的。

# 二进制

## 什么是位、比特、字节？
单个数字 1 或 0，1 位二进制数字命名为位（bit），位是计算机中**存储数据的最小单位** 
通常用**bit**来作数据传输的单位，即传输的二进制字符的个数
字节：`1byte=8bit`，即 1 比特代表 8 位数字，其表示范围为 2^8=256
字节是计算机**存储容量的基本单位**，通常是用**byte**来作文件大小单位

## 32 与 64 位的表示范围

32 位能表示范围为 `4.3 x 10^9`
64 位的表示范围为 `1.8 x 10^19 ` 
## 什么是位址？
为了方便存取数据，计算机必须对内存的地址做标记，这个标记即为**位址**、地址
## 整数的表示
整数分为有符号数和无符号数，有符号数第 1 位表示正负，其中 1 为负，0 为正（补码），其余数字表示实数，而无符号数所有数字都用来表示实数

## 浮点数的表示
浮点数即小数，因小数点可在数位间浮动而得名。
浮点数 = 有效位数 * 指数，最常见的浮点数表示方法为 **IEEE 754 标准** ：32 位数字中，第 1 位表示正负，第 2-9 位存指数. 剩下 23 位存有效位数  
## 如何使用二进制表示字母？
ASCII 给字母编号，适用于英语，容量原为 128 个，后拓展到 256.
UNICODE  由于 ASCII 对中文、日文等语言的不适配所产生的编码标准

## 什么是 ASCII ？
ASCII，American Standard Code for Information Interchange 即美国信息交换标准代码，发明于 1963 年。ASCII 一共 7 位，可存放 128 个不同的值。ASCII 是早期的字符编码标准，在后来拓展到 8 位，后 128 个字符由各个国家自行制定。

## 常见的 ASCII 码☆ 
A-65 a-97

## 什么是 UNICODE ？
UNICODE 设计于 1992 年，是一种字符编码标准，解决了 ASCII 不够表达**所有语言**的问题。UNICODE 有多种标准，最常见的 UNICODE 为 16 位，可表示超过一百万个字符。


# 算术逻辑单元

## 什么是算术逻辑单元？
**算术逻辑单元**，Arithmetic & Logic Unit，简称 ALU，是计算机中负责**运算**的组件，处理数字 / 逻辑运算的最基本单元。ALU 有 2 个单元组成：1 个**算术单元** (Arithmetic Unit) 和 1 个**逻辑单元**（Logic Unit）。ALU 使得计算机能够有意义的处理数字，真正的实现了数字的计算

## 什么是算术单元？
算数单元负责计算机里的所有数字操作，处理包括加减法、带进位的加法、带借位的减法、取反、增量（+1）、减量（-1）在内的基本数学运算。需要注意的是，简单的 ALU 中没有专门的电路来处理**乘除法**，需将其转换为**多次加减法**来实现。

半加器
原理：就二进制加法而言，以 bit 为基本单位，共有四种情况, 而前三种情况和 XOR 门的逻辑完全一样, 对于第四种情况，可以使用 AND 来判断是否进位。
| NUm1 | Num2 | output | carry |
| --- | --- | --- | --- |
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

![500](https://cly1-1305183930.file.myqcloud.com/img/20221120114155.png)
**半加器**能够处理两个 bit 的数字的相加，输出相加的结果并判断是否需要进位，但如果要实现完整的加法，我们需要实现三个数字的加法 (NUm1、Num2、Carry)

**全加器** : 两个半加器 + OR **—> 全加器**（处理多位数字相加）**—>** 封装成单独组件
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120114722.png)

**8 位行波进位加法器**
![500](https://cly1-1305183930.file.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-11-20%2011.54.37.png)

## 什么是溢出？ 
要计算的数字超出了计算机所能表示的范围的现象叫做**溢出**(overflow)，这会导致错误和不可预期的结果。如在上述 8 位行波进位加法器中，若第 8 位的进位为 1，则出现溢出。
通过加更多的全加器，来允许操作 16 或 32 位及更大位的数字，但代价是更多的逻辑门及耗时，这在如今每秒几十亿次的运算中不可忽视，因而现代的加法器使用了**超前进位加法器**。

## 什么是逻辑单元?
逻辑单元执行逻辑操作，如 NOT、AND、OR 等操作，以及做简单的数值测试，如判断一个二进制数是否为 0、判断 CPU 的指令对应的操作码
例如 : 检查 ALU 输出是否为 0 的电路（由一堆 OR 门最后加个 NOT 门构成）


ALU 的抽象

作用 : ALU 的抽象让工程师**不再考虑逻辑门层面的组成**，简化工作

输入输出 : 输入待操作数 A、B 及操作代码 C，输出运算结果及 Flag 标志  

Flag 标志 : OVERFLOW判断是否溢出、ZERO是否为零、NEGATIVE是否小于
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120165955.png)

# 寄存器 & 内存
RAM Random Access Memory 随机存取存储器，只有电源开启时才能存储
Persistent Memory 持久存储

如何利用逻辑门实现存储功能？

以一个 OR 门为例，自环的 OR 门可以存储 1，同理自环的 AND 门可以存储 0
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120171508.png)

**AND-OR 锁存器 (AND-OR LATCH)**, 它使用了 set 作为输入 (左上)、reset 作为控制 (左下)、output 作为输出，
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120172446.png)

在 AND-OR 锁存器的基础上加入了**门锁**，即 Gated Latch，当 Write Enable 为 0 时，输入不会影响输出，即只读；当 Write Enable 为 1 时，输出等于输入，即实现了写入操作。
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120175010.png)

一个锁存器只能存储 1bit 的数据，为了存储更多的数据，我们可以将一组 Gated Latch 并排放，并使用一根线连接所有的 Write Enable 以控制读写，这样就构成了一个**寄存器 (register)**，组成寄存器的锁存器的个数即为其存储容量-**位宽 (width)**。8 位 -> 16 位 -> 32 位 -> 64 位  
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120180805.png)



门锁矩阵 (LATCH MATRIX)
当位宽增长到 64 位，寄存器所需的线路就达到了 129 条，为了简化和精准的控制读写, 需要使用使用矩阵来解决这个问题
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120183141.png)

需要注意的是在矩阵中我们**一次只使用一个**锁存器。

控制线路分别连接到每行 (Row) 和每列 (Column)，这样每个 Gated Latch 有两个 Select Test 的输入，我们使用 AND 门接收控制电路信息，运算结果，即只有当对应的行列所在的控制电路为 1 时 Gated Latch 才可读写。通过控制线路我们实现了对矩阵中单个锁存器的选择。

此外还使用了三根线路连接到所有的 Gated Latch：分别为 Data Input/Output、Write Enable、Read Enable。上述 Select Test 的 AND 门的运算结果分别和 Write Enable 和 Read Enable 连接到 AND 门以实现对读写权限的控制。 

通过矩阵，我们大大简化了线路的使用对于一个 256 位的寄存器，我们只需要 32+1+1+1=35 即可

为了在矩阵中找到对应的寄存器我们还需要定义一个概念，**位址**Memory Address 即内存地址，以 256 位矩阵寄存器为例，其行列为 16 位，可用 4 个 bit 来表示，如 12 行 8 列的寄存器**位址**为 `11001000`，为了将位址转换为行列，我们可以通过**多路复用器**来实现，多路复用器可以根据接收到的地址，将对应的行、列启用

256-Bit 内存模块
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120190516.png)
将八个内存模块连到一起即得到了 256-byte 的内存模块
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120195951.png)
可将其简化为一个整体的可寻址内存拥有 256 个位址为 8bit 的地址
![500](https://cly1-1305183930.file.myqcloud.com/img/20221120200215.png)

随机存取存储器 : RAM（Random Access Memory），由一系列**矩阵以及电路**组成的器件，可根据地址来写入、读取数据
RAM 的一个重要特性是支持随机访问，即可以随时访问任何位置
SRAM Static RAM 静态随机存取存储器
DRAM
NVRAM
Flash Memory闪存

# 中央处理器 (CPU)
## 什么是 CPU？
CPU，Center Processing Unit 即中央处理单元，负责执行程序，程序由一个个指令 (Instruction) 构成
## CPU 的组成？
重点在于功能的实现，当使用一根线连接两个组件 (component) 时，这条线只是所有必须线路的一个抽象。这种表示方法叫做**微体系架构**(Microarchitecture)
上节课构建的 256-byte 的内存模块，和 4 个 8-bit 寄存器用来临时存放和操作数据

![500](https://cly1-1305183930.file.myqcloud.com/img/20221122112559.png)

两个额外的寄存器：
指令地址寄存器 (Instruction Address Register) 用于追踪程序运行的进度
指令寄存器 (Instruction Register) 用于存储当前指令

通常由**寄存器** + **控制单元** + **ALU** + **时钟组成**，与 **RAM** 配合，执行计算机程序

CPU 和 RAM 之间用“地址线”、“数据线”和“允许读/写线”进行通信

重要组件

指令表 : 给 CPU 支持的所有指令分配 ID，其由指令、描述、操作码、地址或寄存器组成  

指令寄存器 : 用于存储当前指令， 即具体的指令代码  

指令地址寄存器 : 用于追踪程序的运行进度、存储当前指令的内存地址、让 RAM 按**顺序**将数据交给指令寄存器  


## CPU 运行的过程是怎样的？
所有的寄存器初始值都为 0
1. 取指令阶段：负责获取指令 (fetch phrase)，将指令地址寄存器连到 RAM，获取地址为 0 的 RAM 中的数据到指令寄存器，完成指令的获取
2. 解码阶段：根据取到的指令，使用**控制单元**对其进行解码，下图即为一个识别操作码为 `0010` 的控制单元 
   ![500](https://cly1-1305183930.file.myqcloud.com/img/20221122114010.png)
3. 执行阶段：**控制单元**识别到命令后，执行相应的操作后，将指令地址寄存器+1，执行阶段结束

![500](https://cly1-1305183930.file.myqcloud.com/img/20221122114622.png)


注 : 指令指示计算机要做什么，多条指令共同组成程序，如 CPU 会让 ALU 处理**数学指令**、**内存指令**会使 CPU 与内存通信  



## 什么是时钟？
时钟 (clock) 负责管理 CPU 运行的节奏，以精确的间隔触发电信号，控制单元用这个信号来推动 CPU 的内部操作。CPU 执行“取指令 —> 解码 —> 执行”中每一步的速度叫做**时钟速度**(Clock Speed)，单位赫兹 Hz，表示频率

第一个单芯片 CPU 是英特尔 1971 年发布的 4 位 CPU 英特尔 4004 ，其时钟速度为 740kHz
![500](https://cly1-1305183930.file.myqcloud.com/img/20221122120442.png)

超频 : 修改时钟速度，加快 CPU 的速度，超频过多会让 CPU 过热或产生乱码
降频 : 降低时钟速度，达到省电的效果，这对笔记本 / 手机很重要  

动态调整频率 : 为了尽可能地省电，很多现代处理器可按需求加快或减慢时钟速度  

## CPU 的组成
1. 两个用来存储指令和指令的地址的寄存器
2. 上述寄存器 + 解析指令的逻辑单元 + 实现指令的线路 = 控制单元 (Control Unit)
3. 一组用于临时存储数据的寄存器
4. 一个用于辅助计算的 ALU 
5. 一个用于控制 CPU 运行速度的时钟，现代 CPU 的时钟通常是可变频的
![500](https://cly1-1305183930.file.myqcloud.com/img/20221122120933.png)



# 指令和程序
在上一讲的基础上拓展了 CPU 的指令集，并且开始设计到一些软件

CPU 是计算机“可编程性”的关键，根据写入指令的不同，CPU 会执行不同的命令。

指令集 : 记录指令名称、用法、操作码以及所需 RAM 地址位数的表格

指令的分类
| 指令类型 | 地址类型 | 描述 |
| --- | --- | --- |
| LOAD | 4-bit RAM address | 将 RAM 中的数据传至寄存器 |
| STORE | 4-bit RAM address | 将寄存器的值存入 RAM 的指定地址 |
| ADD | 2-bit register address × 2 | 将两数和存到第二个地址 |
| SUB | 2-bit register address × 2 | 将两数差存到第二个地址 |
| JUMP | 4-bit memory address | 跳转到 RAM 中对应的命令处 |
|  JUMP-NEG| 4-bit memory address | 当 ALU 的 NEG 为负时跳转  |
| HALT | - | 终止程序 |

JUMP 指令的使用可能会导致无限循环，为了及时终止程序。我们需要有条件的 JUMP，如 JUMP JUMP-NEG



我们做的最基础的 CUP 指令为 8-bit (4-bit 操作码+4-bit 地址)，只能使用 16 个指令和操作 16 个地址，最直接的扩容方法是增加指令长度 (Instruction Length)，还有“可变扩展指令长度”，将指令分为固定长度的操作码和立即值 (Immediate Value)



背景 : 早期计算机每个字只有 8 位，指令只占 4 位，意味着只能有 16 个指令，这远远不够

1971 年[[Intel|英特尔]]发布了 4004 处理器，这是第一个 CPU 芯片，支持了 46 个指令

# 高级 CPU 设计


早期通过减少晶体管的切换时间，来提升 CPU 速度，但很快该方法到达了极限  
后来给 CPU 设计了专门电路替代标准电路来做复杂操作，如游戏、视频解码（例如 **MMX、3DNOW、SSE** 处理器）等
早期[[Intel|英特尔]]的 4004 指令集只有 46 条指令，但已经能够完成基本的操作，而现代 CPU 的指令集多达上千条，这是为了“向后兼容性”(Backwards Compatibility)
随着 CPU 计算速度的提高 RAM 的读取速度成了提高计算速度的瓶颈。我们知道在 CPU 和 RAM 件有许多线相连用于传输数据，如 Data Input/Output、Write Enable、Read Enable 等，即**总线 (Bus)**。虽然总线一般就几厘米长，而电信号在线路的传播借鉴光速，RAM 还需要找地址、取数据、配置、输出数据等一系列操作，一条 LOAD 指令可能需要数个时钟周期。

在 CPU 里内置一些 RAM 称为 **缓存 (Cache)** 以解决延迟的问题，缓存一般只有 KB 或 MB。CPU 从 RAM 中取数据时不用只取一个而是传一批数据。当想要的数据已经在缓存中，这种情况叫做缓存命中 (Cache Hit)，单只叫做缓存未命中 (Cache Miss)，此外缓存也可以作为临时空间存储中间值，以便于进行复杂的运算。使用缓存会带来一个问题：如果 Cache 和 RAM 中对应的数据不一致了，应该怎么办？如何判断不一种的数据是要计算的结果
缓存里每块空间都有一个特殊标记叫**脏记** (Dirty Bit)。缓存和 RAM 的同步发生在缓存满了而 CPU 又需要新的缓存时，在清空缓存之前会先检查脏位，如果是脏的。就将数据写回 RAM。 

**指令流水线**(Pipeline) 是基于这样一个前提，即指令的处理是阶段性的而且指令之间的不同阶段不会互相影响。CPU 的处理过程正是如此，`取址 —> 解码 —> 执行` 
![500](https://cly1-1305183930.file.myqcloud.com/img/20221126132159.png)

![500](https://cly1-1305183930.file.myqcloud.com/img/20221126132207.png)


使用指令流水线必须保证 CPU 能够判断**数据的依赖性**以便及时停止流水线，高端 CPU 能够动态排序有依赖关系的指令以最小化流水线的停工时间，这叫做**乱序执行** (Out-of-order Executation)

条件跳转, 条件跳转会改变程序执行的指令流，同样，简单的 CPU 在遇到跳转时及时停止流水线，而现代的 CPU 会预测可能性最大的的执行分支并继续流水线的执行，这叫做**推测执行 (Speculation Execution)**，如果 CPU 猜错了，会清空流水线 (Pipeline Flush)，为了减少清空的次数，CPU 厂商开发了分支预测 (Branch Prediction)。
现代 CPU 的成功预测率已经达到了 90%，理想情况下一个时钟周期执行一个指令。然后超标量处理器 (Superscalar Processors) 出现了。其本质是同时执行不同类型的命令以充分使用 CPU 的各个部分的计算功能。也可通过增加 ALU 数量以执行出现频次较高的命令，可以同时执行过个数学运算

多核处理器 (Multi-core Processor) 是指有多个独立处理单元的 CPU 芯片可以**同时运行**多个指令流

超级计算机  (Supercomputer)，在一台计算机中，用无数个 CPU，可以做非常非常复杂的运算，如模拟宇宙形成. 例如中国的“**神威-太湖之光**”共有 40960 个 CPU 每个 CPU 有 256 个核心，每秒可进行 9.3 亿亿次浮点运算 (FLOPS，Floating Point Math Operations Per Second)


# 早期的编程方式


穿孔纸卡  

原理 : 通过在纸卡上打孔来记录**数据**，用读卡器读取连通电路，进行编程

缺点 : 操作单一，不能编程  



插线板

原理 : 通过插拔线路的方式，改变器件之间的连接方式，进行编程

缺点 : 操作复杂、连线非耗时



面板拨开关

原理 : 通过拨动面板上的开关，进行编程



冯诺依曼计算机

历程 : 第一台冯诺依曼架构的“存储程序计算机”由曼切斯特大学于 1948 年建造完成  

标志 : 一个处理器(有算术逻辑单元) + 数据寄存器 + 指令寄存器 + 指令地址寄存器 + 内存(负责存数据和指令)